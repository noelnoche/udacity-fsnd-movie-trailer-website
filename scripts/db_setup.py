#!/usr/bin/env python3
"""
This script holds the functions that make the API requests, process the
JSON data and build a single grid in HTML where each tile holds movie
data (graphic, YouTube trailer link, story etc.)

Attributes:
    API_KEY (str): YouTube Data API key.
    PLAYLIST_ID (str): YouTube playlist id.
    CES_ID (str): Google Custom Search Engine id.
    movie_tile_template (str): Template for a single movie entry.
"""
import html
import json
import os
import dev_config
import re
import sqlite3
import sys
import time
import webbrowser
from urllib import parse
from urllib.request import Request
from urllib.request import urlopen
from urllib.error import URLError


class Movie(object):
    """
    This class provides the necessary code for storing and using movie
    information.

    Args:
        title (str): The movie title.
        storyline (str): The movie synopsis.
        poster_image_url (str): Link or path to movie poster data.
        trailer_youtube_url (str): Link to movie trailer on YouTube.
        link (str): URL to the movie's IMDb page.
    """
    def __init__(self, title="No data", storyline="No data", image="No data", 
        trailer="No data", link="No data"):
        self.title = title
        self.storyline = storyline
        self.poster_image_url = image
        self.trailer_youtube_url = ("https://www.youtube.com/watch?v="+trailer)
        self.link = link

    def show_trailer(self):
        """
        Opens the link to the movie trailer.
        """
        try:
            webbrowser.open(self.trailer_youtube_url)
        except webbrowser.Error as e:
            msg = "@Movie.show_trailer -- {}".format(e)
            print(msg)


def http_get_request(url):
    """
    Makes HTTP GET requests from constructed API urls.

    Args:
        url (str): URL for making the API request.
    """
    request = Request(url)

    try:
        response_obj = urlopen(request)
        response_data = json.loads(response_obj.read())
        return response_data
    except URLError as e:
        msg = "@http_get_request -- {}".format(e)
        print(msg)


API_KEY = dev_config.secret["API_KEY"]
PLAYLIST_ID = dev_config.secret["PLAYLIST_ID"]
CSE_ID = dev_config.secret["CSE_ID"]


def call_youtube_api(page_token):
    """
    Fetches data from YouTube Data API v3.

    page_token (str): Holds the `nextPage` token key from the data 
        retruned from the API (for pagination).
    """
    url = ""

    if page_token == None:
        url = ("https://www.googleapis.com/youtube/v3/playlistItems?part="
            "snippet&maxResults=24&playlistId={}&key={}"
            .format(PLAYLIST_ID, API_KEY))
    else:
        url = ("https://www.googleapis.com/youtube/v3/playlistItems?part="
            "snippet&maxResults=24&pageToken={}&playlistId={}"
            "&key={}".format(page_token, PLAYLIST_ID, API_KEY))

    playlist_data = http_get_request(url)
    
    return playlist_data


def call_imdb_api(title):
    """
    Fetches data using Google Custom Search JSON API v1 specified for IMDb.
    https://developers.google.com/custom-search/v1/overview

    Args:
        title (str): Movie title to search parameter.
    """
    imdb_url = ("https://www.googleapis.com/customsearch/v1?q={}&cx={}&key={}"
        .format(title, CSE_ID, API_KEY))
    imdb_data = http_get_request(imdb_url)

    return imdb_data


def process_youtube_data(playlist_data):
    """
    Processes the data returned from `call_youtube_api` to get the
    movie title, storyline and trailer link.

    Args:
        playlist_data (dict): Decoded json data from the YouTube API.
    """
    movies_array = []

    for item in playlist_data["items"]:
        title = item["snippet"]["title"]
        storyline = item["snippet"]["description"]
        trailer = item["snippet"]["resourceId"]["videoId"]
        movieObj = Movie(title, storyline, "", trailer, "")
        movies_array.append(movieObj)

    return movies_array


def process_imdb_data(movies_array):
    """
    Processes the data returned from `call_imdb_api` to get the
    movie poster and IMDb link.

    Args:
        movies_array (array): Movie objects generated by 
            `process_youtube_data`.
    """
    for movieObj in movies_array:

        # Makes movie title URL safe
        title = parse.quote_plus(movieObj.title)

        imdb_data = call_imdb_api(title)

        # Some YouTube titles have the year in them -- e.g., Labyrinth (1986)
        # Using regular expression substitution to remove it.
        # This is done after the API call for more accurate search results.
        regex = r"(\([0-9]\w+\))"
        title = parse.unquote_plus(title)
        title = re.sub(regex, "", title)
        movieObj.title = title

        poster = imdb_data["items"][0]["pagemap"]["cse_image"][0]["src"]
        imdb_link = imdb_data["items"][0]["link"]
        movieObj.poster_image_url = poster
        movieObj.link = imdb_link


movie_tile_template = """
<div class="col-md-6 col-lg-4 movie-tile text-center" data-trailer-youtube-id=
"{trailer_youtube_id}" data-storyline="{storyline}" data-link="{link}" 
data-toggle="modal" data-target="#trailer">
  <div class="img-box">
    <img src="{poster_image_url}" alt="Movie DVD cover art">
  </div>
    <h2>{movie_title}</h2>
</div>
"""

def create_movie_tiles(movies):
    """
    Builds the movie tiles by filling `movie_tile_template` will data 
    from each movie.

    Args:
        movies (arr): The list of movie objects.
    
    Returns:
        content (str): The data injected movie tiles HTML.
    """
    content = ""

    for movie in movies:

        # Extract the youtube ID from the url
        youtube_id_match = re.search(
            r'(?<=v=)[^&#]+', movie.trailer_youtube_url)
        youtube_id_match = youtube_id_match or re.search(
            r'(?<=be/)[^&#]+', movie.trailer_youtube_url)
        trailer_youtube_id = (youtube_id_match.group(0) if youtube_id_match
            else None)
                               
        data = {
            "trailer_youtube_id": trailer_youtube_id,
            "storyline": html.escape(movie.storyline, True),
            "link": html.escape(movie.link, True),
            "poster_image_url": movie.poster_image_url,
            "movie_title": html.escape(movie.title, True)
        }
        
        content += movie_tile_template.format(**data)

    return content


def create_db(close_conn=True):
    """
    Opens a connection to SQLite database. If no database exists,
    creates a new one.

    Args:
        close_conn (bool): Controls whether to close or return 
            a connection.
    """
    conn = None
    db_path = os.getcwd() + "/movies.db"

    try:
        conn = sqlite3.connect(db_path)
        print("SQLite3 -- {}".format(sqlite3.version))
    except sqlite3.Error as e:
        msg = "@connect_db -- {}".format(e)
        print(msg)
    finally:
        if conn and close_conn == True:
            conn.close()
        else:
            return conn


def create_table_movie(conn=None):
    """
    Creates a new table called "movies" in the connected database.

    Args:
        conn (class): sqlite3.Connection.
    """
    try:
        c = conn.cursor()
        c.execute(
            """
            CREATE TABLE movies 
            (page_num integer, data text)
            """)
        print("Table 'movies' created.")
    except sqlite3.Error as e:
        msg = "@create_table_movie -- {}".format(e)
        print(msg)


def insert_movie_data(conn=None, page_data=None):
    """
    Inserts pages data into the table "movies."

    Args:
        conn (class): sqlite3.Connection.
        page_data (array): Table row data `(page number, movie tiles)`.
    """
    if page_data == None:
        print("No movie data available.")
    try:
        c = conn.cursor()
        c.executemany("INSERT INTO movies VALUES (?, ?)", page_data)
        conn.commit()

    except sqlite3.Error as e:
        msg = "@create_table_movie -- {}".format(e)
        print(msg)


def generate_page_data():
    """
    Generates data for the table "movies."

    Returns:
        Array of data tuples in the form `(page number, movie tiles)`.
    """
    page_data = []
    page_token = None
    timer = 0
    page_num = 1

    while True:
        playlist_data = call_youtube_api(page_token)
        movies_array = process_youtube_data(playlist_data)
        process_imdb_data(movies_array)
        movie_tiles = create_movie_tiles(movies_array) 
        page_data.append((page_num, movie_tiles))
        time.sleep(0.5)
        timer += 0.5

        if timer == 15.0:
            msg = "Time limit exceeded for creating movie table data."
            raise Exception("@generate_page_data -- {}".format())
        elif "nextPageToken" in playlist_data:
            page_token = playlist_data["nextPageToken"]
            page_num += 1
            continue
        else:
            break

    return page_data
    

def create_movies_db():
    """
    Creates a new database for the table "movies."
  
    """
    conn = create_db(False)
    create_table_movie(conn)
    page_data = generate_page_data()
    insert_movie_data(conn, page_data)
    conn.close()


if __name__ == "__main__":
    
    db_path = os.getcwd() + "/movies.db"

    if os.path.isfile(db_path) == True:
        prompt = ("This will overwrite the existing movies.db "
                  "file. Proceed? (Y/N): ")
        valid_yes = ("y", "yes")
        valid_no = ("n", "no")
        
        while True:
            answer = (input(prompt)).lower()

            if answer in valid_yes:
                os.remove(db_path)
                break
            elif answer in valid_no:
                print("movies.db file generation cancelled.")
                sys.exit(0)
            else:
                print("Please enter a valid reply.")
    
    create_movies_db()
